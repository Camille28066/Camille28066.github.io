---
layout: default
---

<head>
    <!-- ...existing head content... -->
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />

    <script>
        L_NO_TOUCH = false;
        L_DISABLE_3D = false;
    </script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.control.css"/>
    
    <meta name="viewport" content="width=device-width,
        initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.2/jquery-ui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/iso8601-js-period@0.2.1/iso8601.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script> <!-- Added leaflet-gpx library -->

    <style>
        #shikokuTimeDimensionMap {
            height: 600px; /* You can adjust the height */
            width: 100%;
            position: relative;
        }
        .leaflet-container { font-size: 1rem; } /* From shikoku_track_ref.html */
    </style>
</head>

<!-- Navigation Tabs -->
<nav style="display: flex; justify-content: flex-end; background: #222; padding: 1.5rem 2rem;">
  <a href="index.html" style="color: #fff; text-decoration: none; margin-left: 1.5rem; font-weight: bold;">Home</a>
  <a href="resume.html" style="color: #fff; text-decoration: none; margin-left: 1.5rem; font-weight: bold;">Resume</a>
  <a href="publications.html" style="color: #fff; text-decoration: none; margin-left: 1.5rem; font-weight: bold;">Publications & Events</a>
  <a href="projects.html" style="color: #fff; text-decoration: none; margin-left: 1.5rem; font-weight: bold;">Projects</a>
  <a href="labs.html" style="color: #fff; text-decoration: none; margin-left: 1.5rem; font-weight: bold;">Labs</a>
  <a href="sidestories.html" style="color: #fff; text-decoration: none; margin-left: 1.5rem; font-weight: bold;">Side Stories</a>
</nav>

<section id="sidestories" style="padding: 2rem; background: #f9f9f9;">
  <h2 style="text-align: center; color: #333; margin-bottom: 2rem;">Side Stories</h2>
  <!-- Content for sidestories page will go here -->
  <p style="text-align: center;">Section japan.</p>
  
  <div id="shikokuTimeDimensionMap"></div>

</section>

<script>
    // Ensure this script runs after the DOM is fully loaded
    // Initialize the map
    var shikokuMap = L.map('shikokuTimeDimensionMap', {
        zoomControl: true,
        preferCanvas: false,
    });

    // Add Esri World Imagery tile layer
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    }).addTo(shikokuMap);

    // TimeDimension plugin setup
    L.Control.TimeDimensionCustom = L.Control.TimeDimension.extend({});

    // Initial period, will be updated after data loading
    shikokuMap.timeDimension = L.timeDimension({
        // period: "PT1M", // Will be set dynamically
    });

    var desiredAnimationDurationSeconds = 60;
    var desiredFps = 30;
    var numAnimationFrames = desiredAnimationDurationSeconds * desiredFps;
    var playerTransitionTimeMs = Math.round(1000 / desiredFps); // e.g., 33ms for 30fps

    var timeDimensionControl = new L.Control.TimeDimensionCustom({
        playerOptions: {
            loop: true,
            startOver: true,
            transitionTime: playerTransitionTimeMs, 
        },
        position: 'bottomleft'
    });
    shikokuMap.addControl(timeDimensionControl);

    var gpxTrackFile = 'shikoku_track.gpx';
    var gpxLayer = new L.GPX(gpxTrackFile, {
        async: true,
        marker_options: {
            startIconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/pin-icon-start.png',
            endIconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/pin-icon-end.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/pin-shadow.png',
            wptIconUrls: { '': 'https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/pin-icon-wpt.png' }
        },
        polyline_options: {
            color: 'rgba(0, 0, 255, 0.3)',
            opacity: 0.3,
            weight: 3,
            lineCap: 'round'
        }
    }).on('loaded', function(e) {
        shikokuMap.fitBounds(e.target.getBounds());

        var coordinates = [];
        e.target.eachLayer(function(layer) {
            if (layer instanceof L.Polyline) {
                var latLngs = layer.getLatLngs();
                function processLatLngs(arr) {
                    arr.forEach(function(latLng) {
                        if (latLng instanceof L.LatLng) {
                            coordinates.push([latLng.lng, latLng.lat]);
                        } else if (Array.isArray(latLng)) {
                            processLatLngs(latLng);
                        }
                    });
                }
                processLatLngs(latLngs);
            }
        });

        if (coordinates.length > 1) {
            var baseTimeForGeoJson = new Date(Date.UTC(2023, 0, 1, 0, 0, 0));
            var timestampsInGeoJson = [];
            for (var i = 0; i < coordinates.length; i++) {
                var pointTime = new Date(baseTimeForGeoJson.getTime() + i * 1000); // 1 second interval for data points
                timestampsInGeoJson.push(pointTime.toISOString());
            }

            var geoJsonData = {
                type: "Feature",
                geometry: { type: "LineString", coordinates: coordinates },
                properties: {
                    times: timestampsInGeoJson,
                    style: { color: "#FF4500", weight: 3 }
                }
            };
            
            var baseGeoJsonLayer = L.geoJson(geoJsonData, {
                style: function (feature) { return feature.properties.style; }
            });

            var animatedLayer = L.timeDimension.layer.geoJson(baseGeoJsonLayer, {
                updateTimeDimension: true,
                addlastPoint: false,
                updateTimeDimensionMode: 'update',
            });
            animatedLayer.addTo(shikokuMap);
            
            // Generate timestamps for the animation control
            var totalOriginalDataDurationMs = (coordinates.length - 1) * 1000;
            var timeIncrementPerFrameMs = 0;
            if (numAnimationFrames > 1) {
                timeIncrementPerFrameMs = totalOriginalDataDurationMs / (numAnimationFrames - 1);
            } else if (numAnimationFrames === 1) {
                timeIncrementPerFrameMs = totalOriginalDataDurationMs;
            }


            var timestampsForControl = [];
            if (numAnimationFrames > 0) {
                 for (var i = 0; i < numAnimationFrames; i++) {
                    var frameTimeEpoch = baseTimeForGeoJson.getTime() + i * timeIncrementPerFrameMs;
                    // Ensure frameTimeEpoch does not exceed the actual last data point's time
                    frameTimeEpoch = Math.min(frameTimeEpoch, baseTimeForGeoJson.getTime() + totalOriginalDataDurationMs);
                    timestampsForControl.push(new Date(frameTimeEpoch).toISOString());
                }
                // Ensure the last timestamp is exactly the end of data if numAnimationFrames > 1
                if (numAnimationFrames > 1 && timestampsForControl.length > 0) {
                    timestampsForControl[timestampsForControl.length - 1] = new Date(baseTimeForGeoJson.getTime() + totalOriginalDataDurationMs).toISOString();
                }
                // Remove duplicates that might arise from Math.min and final adjustment
                if (timestampsForControl.length > 1) {
                    timestampsForControl = timestampsForControl.filter((item, index, self) =>
                        index === 0 || item !== self[index-1]);
                }
            }


            if (timestampsForControl.length > 0) {
                var mapPeriodSeconds = 0;
                if (timeIncrementPerFrameMs > 0) {
                    mapPeriodSeconds = Math.max(1, Math.round(timeIncrementPerFrameMs / 1000)); // Period in seconds, at least 1
                } else if (timestampsForControl.length === 1) { // Only one frame
                     mapPeriodSeconds = Math.max(1, Math.round(totalOriginalDataDurationMs / 1000));
                } else { // No frames, or no duration
                    mapPeriodSeconds = 1; // Default to 1s if no other info
                }

                shikokuMap.timeDimension.options.period = "PT" + mapPeriodSeconds + "S";
                shikokuMap.timeDimension.setAvailableTimes(timestampsForControl, 'replace');
                shikokuMap.timeDimension.setCurrentTime(new Date(timestampsForControl[0]).getTime());
                
                console.log("Number of animation frames for control: " + timestampsForControl.length);
                console.log("Player transitionTime: " + playerTransitionTimeMs + "ms");
                console.log("Map timeDimension period: " + shikokuMap.timeDimension.options.period);
                console.log("Estimated animation duration: " + (timestampsForControl.length -1) * playerTransitionTimeMs / 1000 + "s");

            } else {
                 console.warn("Not enough data or frames to create animation timeline.");
            }

        } else {
            console.warn("No coordinates or insufficient coordinates found in GPX to animate.");
        }
    }).on('error', function(e) {
        console.error("Error loading GPX file: ", e.err);
    }).addTo(shikokuMap);

</script>
